Числовые типы в языке

##Целые числа

Память в компьютере ограниченна и поэтому так или иначе мы можем записать любые отдельно взытые числа, но мы не можем записать неограниченно большой диапазон.
Язык предоставяет несколько встроенных диапазонов целых чисел.
Их можно поделить по двум признакам
1) неотрицательность
    диапазон может включать отрицательные целые числа или только неотрицательные - положительные и ноль.
2) размер диапазона
    Определяется количеством бит, которые используются для записи числа в памяти компьютера. При этом (почти всегда) количество бит кратно 8 - количеству бит в байте, т.к. во многом обработка данных строится на байтах.

Ранее мы уже видели некий целочисленный тип int, который необходимо использовать для функции main.
int main() {}

Несмотря на то, что main не обязан отвечать числом - это единственная функция в языке с такой особенностью - любые другие функции, которые отвечают числом, обязаны вернуть какое-нибудь число.

int func()
{
    return 10;
}

Какие числа допустимы в качестве ответа?

Проблема С/С++ в том, что этот вопрос **не имеет однозначного ответа** с точки зрения языка.
На заре распространения этих языков никого не заботила переносимость между разными платформами, для которой и нужна фиксированность диапазона.
Но не только

int - посмотря на этот тип, можно ли с уверенностью сказать, какого он размера и знаковый ли он?
Это зависит от настроек компилятора.
В языке есть следующие ключевые слова, которые имеют отношение к целочисленному типу:
- char
- short
- int
- long
- unsigned
- signed

Теперь посмотрите на следующие "определения". К каждому из них можно мысленно добавить "что бы это не значило":
char - от character - тип, достаточный чтобы вместить коды "встроенных" символов
short - или же short int - "короткий" целочисленный диапазон
int - от integer - целочисленный тип
long - или же long int - "длинный" целочисленный тип
long long - или же long long int - "очень длинный" целочисленный тип
unsigned - или же unsigned int - "беззнаковый" или же неотрицательный целочисленный тип
signed - или же signed int - "знаковый", или же общий целочисленный тип

То, что вы видите выше - это неуправляемый зоопарк типов, взглянув на который, **невозможно** определить размер диапазона.
И этот зоопарк распространился по **большинству** обучающих материалов.
Правда в том, что на практике есть три ситуации:
1) Нам всё равно, какого типа типа число. Нам просто нужно число. Обычно не думают и пишут "int" и забывают
2) Нам нужно использовать тип строго фиксированного размера. Это очень распространённый класс задач. В таком случае, недостаточно осведомлённые программисты пишут свои типы, которым они гарантируют нужный размер. Если повезёт, эти типы будут работать корректно на разных платформах.
3) Нам нужно использовать стороннюю библиотеку, которую написали недостаточно осведомлённые программисты, которые используют зоопарк выше. Тогда необходимость использовать библиотеку вынуждает нас (местами) тоже использовать этот зоопарк.

Есть пара настоящих ситуаций, в которых нам надо по делу использовать эти ключевые слова, но они значительно выходят за пределы курса
*Для знатоков - signed/unsigned можно разумно использовать в шаблонах.

Что же на самом деле надо делать в случаях 1-3:
1) Если просто надо абы какое число - пишите auto. Не знаете, что нужно - пишите auto. Нет разницы, что писать - пишите auto. **(Почти) всегда пишите auto**.
2) Если нужен строго фиксированный по размеру тип - **для этого есть стандартизированное решение**, о нём подробно ниже.
3) При использовании сторонних библиотек, если нет грамотно реализованного современного C++ интерфейса, а обычно это так, то мы, по сути, обречены использовать зоопарк выше.

Так что делать, если нам надо иметь строго фиксированный по диапазону тип?
Встроенные типы из зоопарка выше нам не подходят, потому что по ним нет (почти) никаких гарантий.
Так, int обычно 32 бита. Но не обязательно. Может быть 16 бит. Или ещё как нибудь.
Обычно long на 32-битных платформах - 32 бита. А на 64-битных - 64 бита.
Единственная гарантия, которую даёт нам стандарт в отношении этих встроенных типов:
размер(char) <= размер(short) <= размер(int) <= размер(long) <= размер(long long)
Всё.

Однако, ещё в 1999м году(!!!) для решения проблемы была добавлена специальная "библиотека":
```
#include <cstdint>
```

После включения можно использовать специально созданные типы, которые **гарантируют** выбранный размер:
1) Неотрицательные целые числа:
uint8_t, uint16_t, uint32_t, uint64_t
2) Общие целые числа:
int8_t, int16_t, int32_t, int64_t

Неотрицательные целочисленные типы начинаются с **u**. Общие целые числа начинаются **без u**.
После "int", как указания, что это целые числа, идёт число - точное количество бит, которые используются для диапазона

С помощью N бит (2 значения, 0 и 1) мы можем записать 2^N разных чисел - это из комбинаторики.
Для неотрицательных чисел диапазоном будет [0..(2^N-1)]
Для обших целых чисел диапазон будет [-2^(N-1)..(2^(N-1)-1)]
И там и там всего 2^N счиел.

Примеры:

uint32_t a = 50;
Величина "а" может предтставить числа от 0 до 2^32-1. Всего 2^32 чисел.

int16_t b = -100;
Величина "b" может предтставить числа от -2^15 до 2^15-1. Всего 2^16 чисел.

Только посмотрев на имя типа мы можем сказать о нём всю нужную информацию.
Просто сравните эти 8 типов с зоопарком выше.

Как я и говорил ранее, разработчики неизбежно сталкиваются с необходимостью использовать типы определённого размера, и изобретают свои типы, которые с одной стороны, делают то же самое, с другой - на самом деле могут не работать между разными платформами (процессорами).
Проблема - в массах нету знания того, что эти типы уже есть на уровне стандарта языка, и уже очень давно.

Итог - не пишите в своём коде слова unsigned, signed, short и long вообще.
Тех, кто призывает это делать спрашивайте, зачем это надо и почему вместо этого не использовать auto либо типы фиксированного размера. Шансы в том, что они просто не знают об `#include <cstdint>`


Бонусы:
1) суффикс "_t" не является сокращением от "type". Это сокращение от "typedef", что значит "заменитель типа", "псевдоним типа", причём везде, где вы увидите суффикс "_t" в стандартных типах. Опять таки, эту мелочь не все знают.
2) <cstdint> предоставляет ещё несколько стандартных типов целых чисел, но они выходят за рамки этого курса и по сути нужны только тем, кому нужны.

##(Псевдо)вещественные числа

Невозможно никакими способами изобразить все вещественные числа из любого диапазона. Это достаточно просто доказать.
Однако можно
1) Записать любое выбранное вещественное число по отдельности
2) Приблизить множество вечественных чисел с помощью некоторого подмножества рациональных чисел.

Главные слова - **с помощью**. Но не "посредством"
Языки С/С++ предоставляют несколько типов чисел, которые используют как вещественные:
float
double
long double

Следующие пары строк идентичны:
```
auto a = 0.0f; // обязательна десятичная точка и строчная F
float a = 0;

auto b = 0.0; // обязательная десятичная точка
double b = 0;

auto c = 0.0l; // обязательна десятичная точка и строчная L
long double b = 0;
```

На данном этапе *достаточно* знать следующие факты:
1) в графике типом по умолчанию является float. Просто потому что железо (графические процессоры) строятся на основе этого типа
2) Если вам просто нужны математические расчёты, используйте double посредством auto. Главная часть тут десятичная точка.
3) Если вам окажется недостаточно точности double - тогда используйте long double.

Это не был бы C++, если бы не было дополнительных предостережений.
Без специальных разъяснений, как устроены эти псевдовещественные числа, можно сказать, что почти всегда float - 32 бита, double - 64 бита. long double - как повезёт.

Устройство этих чисел, также известных как числа **с плавающей точкой** - floating point numbers - тема отдельной лекции, и на практике само устройство не часто надо.

Но нужно всегда всегда всегда помнить, что это суррогатные псевдовещественные числа, и с ними могут произойти крайне странные вещи. На первый взгляд странные. Естественно, всё объяснимо.
Сложите 10 раз 0.1f и сравните с 1.0f. **Это будут разные числа**.
Узреть самим: https://onlinegdb.com/SyL8vOcow

Вот тогда понадобится поднимать теорию float чисел. Ну или ради интереса разве что.

Последнее:
**Никогда не сравнивайте float числа на равенство!** Они могут быть равны только *специально*!
Равенство float чисел следует проверять с помощью специальной величины точности сравнения, epsilon.

```
#include <cmath>

auto const epsilon = 0.0001f;

...

float a = heavyCalculus1();
float b = heavyCalculus2();

if(abs(b-a) < epsilon)
    std::cout << "Они равны" << std::endl;
else
    std::cout << "Они не равны" << std::endl;
```

Это тоже не самый полный ответ, но для понимания достаточно.