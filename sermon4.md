# Тема занятия - вопросы разбиения программы на несколько файлов.

Возьмём нашу исходную программу, которая считает сумму двух чисел:
```
// main.cpp:
#include <iostream>

int input()
{
    auto res = 0;
    std::cin >> res;
    return i;
}

int sum(
    int const& a,
    int const& b);
{
    return a + b;
}

void write(int const& n)
{
    std::cout << n << std::endl;
}

int main()
{
    auto const a = input();
    auto const b = input();

    auto const c = sum(a, b);

    write(c);
}
```
Разобъём программу на несколько файлов, т.е. просто перенесём функции в свои файлы:
```
// main.cpp:
#include <iostream>
int main()
{
    auto const a = input();
    auto const b = input();

    auto const c = sum(a, b);

    write(c);
}

// input.cpp:
int input()
{
    auto res = 0;
    std::cin >> res;
    return i;
}

// sum.cpp:
int sum(
    int const& a,
    int const& b)
{
    return a + b;
}

// write.cpp:
void write(int const& n)
{
    std::cout << n << std::endl;
}
```
После вынесения функций в новые файлы попробуем запустить, смотрим, что ничего не получилось.
Что обозначает это "ничего не получилось"?

На самом деле от написания кода до запуска проходит несколько стадий:
1) Компиляция (перевод).
Каждый файл исходного кода по отдельности друг от друга проходит этап перевода с языка С++ на язык машинных команд, которые понимает непосредственно процессор. Этот перевод называется компиляция.
Можно считать, что компилятор - это переводчик с С++ на процессорный язык.
Из каждого файла исходного кода - \*.cpp - формируется объектный файл \*.obj. Это вспомогательный файл, промежуточный. К пользователю он не попадает. Иногда когда говорят "объектник" подразумевают файл исходного кода, т.к. промежуточные файлы не представляют практического интереса, за крайне редкими случаями.
Каждый файл обрабатывается по отдлельности от других, поэтому на этапе компиляции функции не могут знать о функциях, расположенных в других файлах.
Именно поэтому компилятор при обработке main.cpp выдаёт ошибки о том, что ему не известны input, sum и write.
Ещё раз - без специальных указаний исходные файлы ничего не знают о других.
2) Компоновка (сборка).
После того, как все исходники скомпилированы, компоновщик собирает результаты компиляции всех файлов из (1) - объектные файлы \*.obj - и компонует (собирает) из них единый итоговый модуль. Такие модули мы видим с расширением \*.exe, \*.dll. Далее некоторое время я могу упоминать его как "сборщик" просто для упрощения понимания, хотя это не до конца правильно. Так вот сборщик отдаёт конечные файлы, которые мы отправим пользователю. Компоновщик имеет полную картину о наличии разных функций в разных файлах. Строго говоря, компоновщик собирает не только наш код, но и код библиотек, которые используются нами. Про это будет сказано позже, главное помнить, что у компоновщика есть полная картина о наличии/отсутствии функций.
3) Запуск.
Среда исполнения (операционная система) ищет функцию main() и выполняет её либо до окончания работы этой функции, либо до прерывания выполнения со стороны среды.

Компилятор и сборщик могут ругаться на ошибки по отдельности друг от друга.
Компилятор ругается на текст наших файлов, синтаксис языка и прочее.
Сборщик же ругается на отсутствие или же множественное присутствие функций в комплекте собираемых файлов.

Иногда мы можем исправить все ошибки компиляции, но ошибки сборки останутся.
Сборщик по сути своей работы может начать работу только после того, как все файлы скомпилированы. Поэтому могут быть ситуации, когда все ошибки компиляции файла ушли, но потом уже сборщик будет выдавать по нему ошики, как все остальные файлы начнут успешно компилироваться.

Теперь вернёмся к коду.
Добавим в main.cpp объявление функции - обещание компилятору, что компоновщик найдёт эту функцию в других файлах.
```
// main.cpp:
#include <iostream>

extern int input();
extern int sum(int const& a, int const& b);
extern void write(int const& n);

int main()
{
    auto const a = input();
    auto const b = input();

    auto const c = sum(a, b);

    write(c);
}
```
Мы дали три обещания компилятору, что хотя он не найдёт определений функций, они есть где-то ещё, за пределами этого файла.
По сути это некоторое указание для компоновщика.

"extern" - это указание искать определение функции за пределами этого файла.

Объявление функции - это только заголовок. Определение - фактический текст функции.
С точки зрения сборки - объявлений может быть сколько угодно, но определение должно быть строго одно.
```
// объявление, вместо текста функции - точкой с запятой ";"
extern int input();

// определение, текст функции присутствует, в конце не нужна точка с запятой ";"
int input()
{
    ...
}
```
Если два и более определения одной и той же функции будут найдены в одном файле - будет ругаться компилятор.
Если два и более определения одной и той же функции будут найдены в разных файлах - будет ругаться сборщик.

Вторая (более мелкая) проблема в том, что раз каждый файл компилируется по отдельности, то в каждом из них необходимо добавлять строки включения стандартной библиотеки. При этом, непосредственно в main.cpp мы НЕ используем std::, поэтому можно убрать строку #include <iostream> из main.cpp.

Третье замечание.
Как мы знаем, программа обязана иметь функцию main. За этим следит сборщик. Поэтому компилятор НЕ будет ругаться на отсутствие функции main. Компоновщик будет ругаться, если не найдёт main ни в одном из файлов или же найдёт их больше одной. Всё точно так же, как и с любыми другими функциями.

Получаем следующее:
```
// main.cpp:
extern int input();
extern int sum(int const& a, int const& b);
extern void write(int const& n);

int main()
{
    auto const a = input();
    auto const b = input();

    auto const c = sum(a, b);

    write(c);
}

// input.cpp:
#include <iostream>

int input()
{
    auto res = 0;
    std::cin >> res;
    return res;
}

// sum.cpp:
int sum(
    int const& a,
    int const& b)
{
    return a + b;
}

// write.cpp:
#include <iostream>

void write(int const& n)
{
    std::cout << n << std::endl;
}

https://onlinegdb.com/N1mRev21t
```
Всё работает как положено.

Итак, extern позволяет нам по сути использовать функции, определённые в других файлах.
Плюсы:
 - Мы можем разделять одну программу на несколько файлов, которые объединят логически связанные куски. Это позволяет уже не теоретически, а практически разделить ответственность за написание кусков программы между членами команды. Один файл может ожидать, что другой реализует нужную функцию

Минусы:
 - Все функции по умолчанию могут быть обнаружаемы из других файлов. Это значит, что если двум разным файлам *надо* иметь свои функции с одинаковыми именами и аргументами, то произойдёт ошибка на этапе компоновки. Нужно предотвращать случайный конфликт имёт в пространстве модуля.
 - Если функция имеет исключительно внутренне назначение, и меняет какую-либо переменную, специфическую для файла, то такая функция обязана быть недоступна снаружи файла, чтобы предотвратить неуправляемые вызовы, как случайные, так и намеренные. Нужно закрывать функции от доступа извне файла.
 - Нам приходится следить за тем, чтобы в разных файлах не было функций с одинаковыми названиями. С ростом количества разработчиков это прогрессирующая головная боль. Нужно разрешать конфликты имён в одном "модуле", т.е. наборе объектников.

Итог: Обычно мы пишем функции в отдельных файлах для того, чтобы использовать эти функции в других файлах. Однако есть случаи, когда нам необходимо защитить функцию от внешнего доступа.

Для этого было придумано ключевое слово "static".
Пример:
```
// func.cpp:
void f() {}

static void g() {};

// main.cpp:
// это будет найдено 
extern void f();

// на этом сборщик будет ругаться, т.к не может найти 
// функцию g(), которая явно закрыта для доступа
extern void g();

int main()
{
    f();

    g();
}   
```
static не просто закрывает доступ, он закрывает также видимость.
То есть другие файлы не просто не могут вызвать эту функцию, сборщик даже не может определить, что такая функция где-то есть.
"Отсутствие доступа" и "отсутствие видимости" - два разных состояния, строго говоря.

Пример.
Скажем, на карте есть комната, у неё одна дверь. Обычно мы комнаты распознаём по наличию дверных наличников, ручек и т.п.
Вариант 1.
Дверь в эту комнату - стеклянная, но заперта. Игрок видит дверь и комнату за ней. Есть видимость комнаты, но нет доступа.
Вариант 2.
Дверь в эту компнату - точная копия и вообще композиционая часть окружающих стен. При этом игрок может просто толкнуть камень и дверь откроется. Есть доступ но нет видимости.

На подумать - видимость двери не означает наличие комнаты за ней.

Далее.

Предположим, мы хотим сделать "сумму по модулю" вместо простой суммы (остаток от деления суммы на некоторый делитель).
И почему-то хотим запрашивать делитель прямо внутри функции:

sum.cpp:
extern int input();

int sum(
    int const& a,
    int const& b)
{
    auto const c = input();
    return (a + b) % c;
}

Операция процент - "%" - обозначает деление по модулю, остаток от деления на число.

Так как int input() определяется в файле input.cpp, то сборщик найдёт эту функцию.

Теперь у нас есть два абсолютно одинаковых "обещания" того, что где-то будет функция input(). Если вдруг надо будет изменять объявление функции input, то это придётся делать дважды. Если эта функция будет "обещаться" ещё где-то, то количество таких объявлений возрастёт. На практике, этот сценарий является неизбежностью развития проекта. Более того, в сложных программах старшие программисты всячески борются за то, чтобы сокращать количество зависимостей. Ещё раз: распространение зависимостей будет происходить само собой; усилия прикладываются, чтобы это остановить.
Как бы там ни было - мы бы НЕ хотели менять здоровенное количество файлов, если потребуются правки в объявление функции input

Поэтому мы создадим новый файл, input.hpp, который будет содержать в себе объявление функции input:

```
// input.hpp:
extern int input();
```

Затем в main.cpp и sum.cpp мы объявления заменим на строку #include "input.hpp"
```
// main.cpp:
#include <iostream>

#include "input.hpp"

extern int sum(int const& a, int const& b);
extern void write(int const& n);

int main()
{
    ...
}

// sum.cpp:
#include "input.hpp"

int sum(...)
{
    ...
}
```
Пробуем запускать - всё работает.
Как это работает, и главное - что именно работает?
Мы уже видели слова "#include" ранее, например #include <iostream>
#include "input.hpp" 
вставляет текст файла "input.hpp" вместо этой строки. Всё.

Теперь что нужно знать:
 - #include <iostream> вставляет текст файл с именем "iostream", который ищется в "библиотечных папках". Что значат эти слова - "библиотечные папки" - прямо сейчас абсолютно бесполезно знать, мы вернёмся к этому позже. Главное - угловые скобки значат "искать в библиотечных папках".
 - #include "input.hpp" - в отличие от угловых скобок, двойные кавычки значат "сначала поискать файл относительно текущего файла, а если его не будет, то поискать в библиотечных папках

Вывод - #include просто вставляет текст файла. Угловые скобки - искать в "библиотечных папках", двойные кавычки - искать сначала рядом с текущим файлом, а затем в "библиотечных папках", что бы это ни значило.

#include <iostream> точно также просто вставляет файл с именем "iostream", который находится где-то в "библиотечных папках"

В итоге - мы получили ситуацию, в которой объявление функции int input() есть в одном единственном файле, и все, кто хотят использовать функцию input, могуть просто "включить" файл input.hpp.
Файлы, которые подключаются таким образом, называются заголовочными файлами. Они не обязаны иметь какое-либо специфическое расширение или вообще иметь хоть какое-то расширение (iostream это точное название файла, расширения у него нет). Тем не менее, в контексте С/С++ устаканились определённые договорённости
1) "*.h" использовать для заголовочных файлов, совместимых с языком "С"
2) "*.hpp" использовать для заголовочных файлов для языка "С++" и НЕ совместимых с языком "С".
Так как язык стандарта не задаёт, то встречаются и другие названия (*.hh, *.hxx ). Также огромное количество разработчиков ошибочно называют заголовочные файлы языка С++ *.h. Причина - низкая квалификация и плохое качество учебных материалов в индустрии С++ в целом.

Крайне важный момент: один и тот же файл заголовочный файл может быть неявно вставлен в исходник несколько раз.
"#include" просто вставляет текст файла, и почти всегда используется для "включения" заголовочных файлов. В таком виде один и тот же заголовочный файл может появиться в разных заголовочных файлах, которые независимо друг от друга включаются в один исходник несколько раз. Это порождает крайне неочевидные проблемы, связанные с возможным множественным определением функций или переменных в одном и том же исходнике.

Поэтому в начале **каждого** заголовочного файла **первой строкой** необходимо писать "#pragma once". Этот текст предписывает компилятору включать этот файл только один раз, т.е.
```
// A.hpp:
extern void f();

// B.hpp:
#include "A.hpp"
#include "A.hpp"
#include "A.hpp"
```
равносильно
```
// B.hpp:
extern void f();
extern void f();
extern void f();
```
но если добавить в A.hpp #pragma once, то получим
```
// A.hpp:
#pragma once
extern void f();

// B.hpp:
#include "A.hpp"
#include "A.hpp"
#include "A.hpp"
```
равносильно
```
// B.hpp:
extern void f();
```
Также, как мы увидим далее, обычно заголовочный файл включают в соответствующий исходник.

extern и static применимы не только к функциям, но и к переменным:

```
// A.cpp:
int a = 10;

// main.cpp:
extern int a;

int main()
{
    a = a * 2;

    return a; // ответит 20
}
```
Эффект тот же, что и для функций - extern обещает компилятору, что переменная есть в другом файле, static просит компилятор закрыть доступ сборщику.

Теперь суровые нюансы С++.
1) Функции по умолчанию объявляются и определяются extern. То есть следующее равносильно:
```
// объявление 
void f();
// точно такое же объявление 
extern void f();

// определение
void g(){}
// точно такое же определение
extern void g(){}
```
Поэтому для функций обычно НЕ пишут extern. Тем не менее очень важно помнить, что они неявно видимы для других файлов.

Функции нельзя определять внутри других функций, но можно *объявлять* внутри других функций.
На практике, если один файл напрямую использует функцию из другого файла, то это не от хорошей жизни.
В скоре мы узнаем, как это делается "обычно".

2) С переменными сложнее, тут применяется логика С++, т.е. полное отсутствие оной. Это на самом деле дополнительный материал, такое могут спрашивать разве что на собеседованиях на чистый С или от скуки на собеседованиях по С++. В практике хорошего С++ это не часто приходится помнить. Читайте на свой страх и риск. Нет, я серьёзно - далее развлекательный "факты из жизни С/С++". Я знаю все эти детали тоже не от хорошей жизни. И то могу что-то забыть время от времени.
**Начало кошмара**
Объявление переменной без extern и static является также определением.
Значение строки
`int a;`
зависит от того, где находится эта строка
Объявление переменной - значит примерно следующее:
`int a;` - отныне будет новая целочисленная величина с именем "а", без указания начального значения
`int a = 10;` - отныне будет новая целочисленная величина с именем "а", с начальным значением 10. 
`extern int a;` - где-то *в глобальном пространстве* существует целочисленная величина с именем "а"
`extern int a = 10;` - это и объявление и определение и начальное значение. В глобальной области видимости это будет предупреждением со стороны компилятора, в том смысле что переменная и так объявлена extern, не надо это явно указывать. Если эта строка будет в локальной области - это будет ошибка, т.к. функция внутри себя не может просто так создать величины, обнаружимые извне, по простой причине - функция закончит выполнение и все внутренние переменные перестанут существовать.
`static int a;` - отныне будет создана уникальная для данного контекста переменная, которая не будет обнаружима за пределами этого контекста, без начального значения
`static int a = 10;` - отныне будет создана уникальная для данного контекста переменная, которая не будет обнаружима за пределами этого контекста, с начальным значением 10

Верховный ужас проявляется у констант. Но, с другой стороны, постоянные вообще запрещено определять без начального значения.

`int const b;` - ошибка компиляции - невозможно определить постоянную величину без указания её значения.
`int const b = 10;` - определение постоянной величины b со значением 10; если эта величина объявлена в функции, она работает абсолютно точно также, как и без const. Но в глобальной области это не так! постоянные величины в глобальной области видимости имеют неявный static. переменные имеют неявный extern. В таком случае const выступает как ограничитель доступа, что является одним из моих любимых идиотских вопросов на собеседовании. На собеседованиях вообще любят задавать бесполезные на практике вопросы просто чтобы определить вовлечённость кандидата в изучение языка.
`extern int const b;` - где-то в других файлах найдётся постоянная величина b
`extern int const b = 10;` - отличается в поведении от переменных. Такая конструкция разрешена в глобальной области, не вызывает предупреждений у компилятора. А в локальной области точно также запрещена, как и для переменных.
`static int const b;` - ошибка компиляции, т.к. b должна оказаться уникальной и быть задана начальным значением.
`static int const b = 10;` - если эта конструкция в глобальной области видимости, то она идентична int const b = 10; Если в локальной, то эта константа будет уникальна для области видимости

Про static для локальной области видимости надо сказать дополнительно:
Если есть static переменная в функции, то эта переменная будет задана при первом заходе в в функцию, и при каждом очередном заходе это будет всё та же самая переменная.
Пример:
```
void f()
{
    static auto callCounter = 0;
    callCounter = callCounter + 1;
}
```
callCounter - уникальная для функции переменная, доступная только внутри этой функции. В примере выше будет обозначать количество раз, когда функцию вызывали. Эта переменная будет существовать между вызовами функции. Когда функция будет вызвана в следующий раз, значение не сбросится в начальное, а сохранится предыдущее.
**Конец кошмара**

Итоговый итог программы:
```
// main.cpp:
#include "input.hpp"
#include "sum.hpp"
#include "write.hpp"

int main()
{
    auto const a = input();
    auto const b = input();

    auto const c = sum(a, b);

    write(c);
}

// input.hpp:
#pragma once

int input();

// input.cpp:
int input()
{
    auto res = 0;
    std::cin >> res;
    return i;
}

// sum.hpp:
#pragma once

int sum(
    int const& a,
    int const& b);

// sum.cpp:
int sum(
    int const& a,
    int const& b)
{
    return a + b;
}

// write.hpp:
#pragma once

void write(int const& n);

// write.cpp:
void write(int const& n)
{
    std::cout << n << std::endl;
}
```